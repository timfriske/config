# Startup file for Bash login shells
# ==================================
# Tim Friske <me@tifr.de>
#
# The _Bash_ _Bourne Again Shell_ reads and executes commands from its
# configuration files but only if these exist and are readable.  When
# started as a login shell it first reads its system-wide startup file
# `/etc/profile`.  It then continues to read the first of its user-
# specific startup files `~/.bash_profile`, `~/bash_login` and
# `~/.profile` it encounters in that order.  When a login shell is
# exited _Bash_ reads and executes commands from its user-specific
# shutdown file `~/.bash_logout`.
#
# This configuration file shall contain only non-default settings
# specific to login shells in order to keep it lean and thus easy to
# understand and maintain.  In case an interactive login shell is
# started this startup file shall read and execute the commands from
# _Bash's_ user-specific startup file for interactive shells, namely
# `~/.bashrc`.
#
# See also:
#   * man:bash[1]
#   * link:{system-home}/profile
#   * link:{user-home}/.bash_profile
#   * link:{user-home}/.bash_login
#   * link:{user-home}/.bash_logout
#   * link:{user-home}/.bashrc

# Environment variables
# ---------------------

# Remember up to 100,000 one hundred thousand commands in memory and on
# disk.  Record the time when each command entered history as an
# ISO-8601 timestamp.  Exclude commands starting with whitespace from
# history.  Erase all duplicate commands from history before the same
# command is appended to history.  Exclude any command from history
# which matches one of the patterns specified in the ignore list.  In
# other words either a simple command that is spanning only one word, or
# ends in either one of the long options or subcommands `help` or
# `version`.
#
export HISTSIZE=100000
export HISTFILESIZE="$HISTSIZE"
export HISTTIMEFORMAT='%Y-%m-%d %H:%M:%S '
export HISTCONTROL='ignorespace:erasedups'
export HIST_X_IGNORE=()
HIST_X_IGNORE+=('+([![:space:]])*([[:space:]])')
HIST_X_IGNORE+=('*@(help|version)*')
export HISTIGNORE="$(IFS=:; echo "${HIST_X_IGNORE[*]}")"

# Tell programs to open files in favorite text editor _Vim_ _Vi
# Improved_.  Don't care about line-oriented vs. visual editors just
# assign both `$EDITOR` and `$VISUAL` the same editor.
#
export EDITOR='vim'
export VISUAL='vim'

# Make full-text searches with the _Grep_ program more pleasant by
# default in the following ways:
#
#   directories=recurse::
#     If given no files search all files in the current directory and
#     below in a recursive manner.  Otherwise _Grep_ would read from
#     standard input or if given a directory tell the user that it is
#     one.  _Grep's_ default behavior is simply not what users most
#     likely expect it to be.
#
#   binary-file=without-match::
#     If _Grep_ encounters binary files just ignore them.
#
#   devices=skip::
#     If _Grep_ encounters devices just ignore them.
#
#   color=auto::
#     If _Grep_ output is to a terminal colorize it.
#
export GREP_X_OPTIONS=()
GREP_X_OPTIONS+=('--directories=recurse')
GREP_X_OPTIONS+=('--binary-files=without-match')
GREP_X_OPTIONS+=('--devices=skip')
GREP_X_OPTIONS+=('--color=auto')

# Make paging with the _Less_ program more pleasant by default in the
# following ways:
#
#   no-init::
#     Prevent _Less_ from clearing the terminal screen when it quits.
#     This way the user has a chance to refer to the last screen full of
#     output even after _Less_ exited.
#
#   tabs=4::
#     Let _Less_ display each tabulator four spaces wide in order to let
#     its output consume less space on the screen.
#
#   LONG-PROMPT::
#     Let _Less_ to prompt even more verbosely than _More_.
#
#   ignore-case::
#     Let _Less_ search smarter by ignoring the case if the pattern
#     consists of lower-case characters only.  Let it perform a case-
#     sensitive search if the pattern contains upper-case characters.
#
#   jump-target=.5::
#     Let _Less_ position the next or previous line that matches a
#     search pattern in the center of the terminal screen.  This should
#     give the user enough context, i.e. lines surrounding that line.
#
#   hilite-unread::
#     Let _Less_ give the user visual guidance as to where s/he left off
#     reading after paging through a screen worth of output.
#
#   RAW-CONTROL-CHARS::
#     Let _Less_ output colors and escape the rest of `raw' control
#     characters in order to not mess up the terminal screen.
#
#   quit-if-one-screen::
#     Let _Less_ display automatically quit itself if there is less than
#     a screen full of output to display.  Don't let the user have to do
#     that every time.
#
export LESS_X_OPTIONS=()
LESS_X_OPTIONS+=('--no-init')
LESS_X_OPTIONS+=('--tabs=4')
LESS_X_OPTIONS+=('--LONG-PROMPT')
LESS_X_OPTIONS+=('--ignore-case')
LESS_X_OPTIONS+=('--jump-target=.5')
LESS_X_OPTIONS+=('--hilite-unread')
LESS_X_OPTIONS+=('--RAW-CONTROL-CHARS')
LESS_X_OPTIONS+=('--quit-if-one-screen')
export LESS="${LESS_X_OPTIONS[@]}"

# Make listing directories with the _Ls_ program more pleasant by default in
# the following ways:
#
#   si::
#     Let _Ls_ display file sizes as human-readable numbers in powers of
#     1,000 with their units in the _SI_-system, the _International
#     System of Units_ (Système International (d'unités)), e.g. KB, MB,
#     TB etc.  The _SI_-system is also the system in which most storage
#     device capacities are advertised.
#
#   classify::
#     Let _Ls_ append an indicator sign to each type of file to help the
#     user identify its file type, e.g. `/` for directories or `*` for
#     executable files.
#
#   clolor=auto::
#     Let _Ls_ colorize its output if it goes to a terminal.
#
#   group-directories-first::
#     Let _Ls_ list all directories before all other kinds of files,
#     e.g. regular files, symbolic links etc. because such directory
#     listings might be easier on the eye and therefore to comprehend.
#
export LS_X_OPTIONS=()
LS_X_OPTIONS+=('--si')
LS_X_OPTIONS+=('--classify')
LS_X_OPTIONS+=('--color=auto')
LS_X_OPTIONS+=('--group-directories-first')

# Add _Git's_ commit message footer line `Signed-off-by`.
#
export GIT_X_SIGNOFF='--signoff'

# Interactive login shells
# ------------------------

# Test if interactive shell and its startup file is readable.
if [[ "$-" == *i* && -f ~/.bashrc && -r ~/.bashrc ]]; then
  # Read and execute commands from its startup file.
  source ~/.bashrc
fi
