# Startup file for Bash interactive shells
# ========================================
# Tim Friske <me@tifr.de>
#
# The _Bash_ _Bourne Again Shell_ reads and executes commands from its
# configuration files but only if these exist and are readable.  When
# started as an interactive shell it first reads its system-wide startup
# file `/etc/bash.bashrc`.  It then continues to read its user-specific
# startup file `~/.bashrc`.
#
# This configuration file shall contain only non-default settings
# specific to interactive shells in order to keep it lean and thus easy
# to understand and maintain.  In case an interactive login shell is
# started this startup file shall be read and its commands executed by
# the first of _Bash's_ user-specific startup files for login shells
# that _Bash_ encounters, that is `~/.bash_profile`, `~/.bash_login` or
# `~/.profile`.
#
# See also:
#   * man:bash[1]
#   * link:{system-home}/bash.bashrc
#   * link:{user-home}/.bashrc
#   * link:{user-home}/.bash_profile
#   * link:{user-home}/.bash_login
#   * link:{user-home}/.profile

# Terminal settings
# -----------------

# Disable `CTRL-S` and `CTRL-Q` to stop and start terminal output
# because this function is not very useful and just confuses most users.
# The previously bound hot keys can be assigned new functions hereafter.
#
stty -ixon

# Shell options
# -------------

# Edit commands with Vi- instead of Emacs-like key bindings.
#
shopt -os vi

# Make it easy to name and navigate directories.
#
shopt -s autocd cdable_vars cdspell dirspell

# List any stopped and running jobs before exiting an interactive shell
# in order to not kill important jobs unintentionally but exit them
# manually, e.g. by saving their data first.  To list the remaining jobs
# is what most users would usually do if the shell they are about to
# exit reports that there are a number of stopped jobs.
#
shopt -s checkjobs

# Update window size after each command.
#
shopt -s checkwinsize

# Also store multi-line commands in history in case the user wants to
# adapt them later on, e.g. in case of syntax errors.
#
shopt -s cmdhist lithist

# Recognize extended set of patterns during pattern matching and path
# name expansion.
#
shopt -s extglob globstar

# Make command history more accessible.
#
shopt -s histappend histreedit histverify

# Don't overwrite files with `>` file redirection operator.  This
# setting may be overruled adhoc by using the `>|` operator.
#
shopt -os noclobber

# Attempt to complete commands once a non-empty prefix is given in order
# to not list the entire arsenal of commands but an already reduced list.
#
shopt -s no_empty_cmd_completion

# Ignore upper- and lower case during path name expansion and pattern
# matching.
#
shopt -s nocaseglob nocasematch

# Shell aliases
# -------------

# Allow aliases to be run as another user/group, e.g. super user `root'.
#
alias sudo='sudo '

# Ask the user before files are overwritten or deleted in order to
# prevent accidental data loss.
#
alias cp='cp --interactive --verbose'
alias ln='ln --interactive --verbose'
alias mv='mv --interactive --verbose'
alias rm='rm --interactive=once --verbose'

# Alleviate the user from having to manually create or delete every
# intermediate directory.  Introduce the aliases `md` for `mkdir` and
# `rd` for `rmdir` for consistency with the other notorious two-letter
# commands such as `cp`, `mv` or `rm`.
#
alias mkdir='mkdir --parents --verbose'
alias md='mkdir'
alias rmdir='rmdir --parents --verbose'
alias rd='rmdir'

# Make listing directories with the _Ls_ program more pleasant by
# configuring its default behavior.
#
alias ls='ls $LS_X_OPTIONS'
alias la='ls --almost-all'
alias lh='ls --almost-all --ignore="*"'
alias ll='ls --format=long'
alias lt='ls --sort=time'
alias lv='ls --sort=version'
alias lx='ls --sort=extension'
alias lz='ls --sort=size'
alias lla='ll --almost-all'
alias llh='ll --almost-all --ignore="*"'
alias llt='ll --sort=time'
alias llv='ll --sort=version'
alias llx='ll --sort=extension'
alias llz='ll --sort=size'

# Show human-readable file system sizes in powers of 1,000.  Exclude
# neglectable types of file systems.
#
alias df='df --si'
alias dff='df -x devtmpfs -x tmpfs'

# Show human-readable file and directory sizes in powers of 1,000.
# Summarize files and directories up to the current directory.
#
alias du='du --si'
alias dud='du --max-depth=1 | sort --human-numeric-sort --reverse'
alias duf='du --all --max-depth=1 | sort --human-numeric-sort --reverse'
alias dus='du --summarize'

# Show human-readable memory sizes in powers of 1,000 of free and used
# physical and swap memory.
#
alias free='free --human --si'

# Show _UTC_ _Universal Time Coordinated_.
#
alias utc='date --utc'

# Show (calendar) week of year.
#
alias week='date +"week %V"'

# Run given command on every argument usually read from pipe.  The alias
# `map` resembles the well-known mathematical term `mapping' also known
# as `map'.
#
alias map='xargs --max-args=1'

# Make full-text searches with the _Grep_ program more pleasant by
# configuring its default behavior.
#
alias grep='grep $GREP_X_OPTIONS'
alias egrep='grep --extended-regexp'
alias fgrep='grep --fixed-strings'

# Simplify data exchange between CLI and GUI via clipboard.
#
if type -p xclip &> /dev/null; then
  alias pbc='xclip -selection clipboard -in'
  alias pbp='xclip -selection clipboard -out'
elif type -p xsel &> /dev/null; then
  alias pbc='xsel --clipboard --input'
  alias pbp='xsel --clipboard --output'
elif ! type -p pbcopy pbpaste &> /devl/null; then
  alias pbc='echo Please install xclip, xsel or pbcopy.'
  alias pbp='echo Please install xclip, xsel or pbpaste.'
fi

# Define aliases for the most common file permission changes.
#
alias 600='chmod --changes 600'
alias 644='chmod --changes 644'
alias 755='chmod --changes 755'

# Define _Git_ itself as well as all of its aliases as _Bash_ aliases
# with the prefix letter `g`.  The _Git_ aliases will be lazily loaded
# and defined as _Bash_ aliases by the `git` function below.  Upon the
# first time this function is called it dynamically defines one _Bash_
# alias for each _Git_ alias that is defined in one of _Git's_
# configuration files.  It then executes the `git` command with all the
# given arguments as if this function had never existed.  Once completed
# it eventually makes way for the `git` command by undefining itself.
#
function git {
  alias g='git'
  local git_alias
  for git_alias in $(command git config --list --name-only \
      | grep '^alias.' -- - \
      | cut --delimiter=. --fields=2); do
    alias "g$git_alias=git $git_alias"
  done;
  command git "$@"
  unset -f git
}
