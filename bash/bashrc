# Startup file for Bash interactive shells
# ========================================
# Tim Friske <me@tifr.de>
#
# The _Bash_ _Bourne Again Shell_ reads and executes commands from its
# configuration files but only if these exist and are readable.  When
# started as an interactive shell it first reads its system-wide startup
# file `/etc/bash.bashrc`.  It then continues to read its user-specific
# startup file `~/.bashrc`.
#
# This configuration file shall contain only non-default settings
# specific to interactive shells in order to keep it lean and thus easy
# to understand and maintain.  In case an interactive login shell is
# started this startup file shall be read and its commands executed by
# the first of _Bash's_ user-specific startup files for login shells
# that _Bash_ encounters, that is `~/.bash_profile`, `~/.bash_login` or
# `~/.profile`.
#
# See also:
#   * man:bash[1]
#   * link:{system-home}/bash.bashrc
#   * link:{user-home}/.bashrc
#   * link:{user-home}/.bash_profile
#   * link:{user-home}/.bash_login
#   * link:{user-home}/.profile

# Terminal settings
# -----------------

# Disable `CTRL-S` and `CTRL-Q` to stop and start terminal output
# because this function is not very useful and just confuses most users.
# The previously bound hot keys can be assigned new functions hereafter.
#
stty -ixon

# Shell options
# -------------

# Edit commands with Vi- instead of Emacs-like key bindings.
#
shopt -os vi

# Make it easy to name and navigate directories.
#
shopt -s autocd cdable_vars cdspell dirspell

# List any stopped and running jobs before exiting an interactive shell
# in order to not kill important jobs unintentionally but exit them
# manually, e.g. by saving their data first.  To list the remaining jobs
# is what most users would usually do if the shell they are about to
# exit reports that there are a number of stopped jobs.
#
shopt -s checkjobs

# Update window size after each command.
#
shopt -s checkwinsize

# Also store multi-line commands in history in case the user wants to
# adapt them later on, e.g. in case of syntax errors.
#
shopt -s cmdhist lithist

# Recognize extended set of patterns during pattern matching and path
# name expansion.
#
shopt -s extglob globstar

# Make command history more accessible.
#
shopt -s histappend histreedit histverify

# Don't overwrite files with `>` file redirection operator.  This
# setting may be overruled adhoc by using the `>|` operator.
#
shopt -os noclobber

# Attempt to complete commands once a non-empty prefix is given in order
# to not list the entire arsenal of commands but an already reduced list.
#
shopt -s no_empty_cmd_completion

# Ignore upper- and lower case during path name expansion and pattern
# matching.
#
shopt -s nocaseglob nocasematch

# Shell aliases
# -------------

source ~/.bash/rc.d/alias/sudo.bash
source ~/.bash/rc.d/alias/cd.bash
source ~/.bash/rc.d/alias/cp.bash
source ~/.bash/rc.d/alias/ln.bash
source ~/.bash/rc.d/alias/mv.bash
source ~/.bash/rc.d/alias/rm.bash
source ~/.bash/rc.d/alias/mkdir.bash
source ~/.bash/rc.d/alias/rmdir.bash
source ~/.bash/rc.d/alias/ls.bash
source ~/.bash/rc.d/alias/tar.bash
source ~/.bash/rc.d/alias/rsync.bash
source ~/.bash/rc.d/alias/sort.bash
source ~/.bash/rc.d/alias/wc.bash
source ~/.bash/rc.d/alias/df.bash
source ~/.bash/rc.d/alias/du.bash
source ~/.bash/rc.d/alias/file-xyz.bash
source ~/.bash/rc.d/alias/free.bash
source ~/.bash/rc.d/alias/info.bash
source ~/.bash/rc.d/alias/date.bash
source ~/.bash/rc.d/alias/xargs.bash

# Find broken links, i.e. symbolic links which lost their target files
# or folders.  This usually occurs when either the symbolic links or
# their targets move and their references are not updated.
#
alias broken-links='find -xtype l'

# Make comparing differences between files and directories with the
# _Diff_ program more pleasant by configuring its default behavior.
#
alias diff='diff $DIFF_X_OPTIONS'
alias diff-dirs='diff --recursive --brief'

# Make full-text searches with the _Grep_ program more pleasant by
# configuring its default behavior.
#
alias grep='grep $GREP_X_OPTIONS'
alias egrep='grep --extended-regexp'
alias fgrep='grep --fixed-strings'

# The abbreviations `OS' for `operating system' and `distro' for `Linux
# distribution' are better known than the names of the utilities `uname'
# and `lsb_release'.
#
alias os='uname --all'
alias distro='lsb_release --all --short'

# Simplify data exchange between CLI and GUI via clipboard.
#
if type -p xclip &> /dev/null; then
  alias pbc='xclip -selection clipboard -in'
  alias pbp='xclip -selection clipboard -out'
elif type -p xsel &> /dev/null; then
  alias pbc='xsel --clipboard --input'
  alias pbp='xsel --clipboard --output'
elif ! type -p pbcopy pbpaste &> /dev/null; then
  alias pbc='echo Please install xclip, xsel or pbcopy.'
  alias pbp='echo Please install xclip, xsel or pbpaste.'
fi

# Never start from the root directory because this would almost always
# mean to *destroy* the *entire* root file system and *all* file systems
# mounted below.  Report only when and which files and directories
# actually changed.
#
alias chgrp='chgrp --preserve-root --changes'
alias chmod='chmod --preserve-root --changes'
alias chown='chown --preserve-root --changes'

# Just type `open` to open a file or URL in the user's preferred
# application.  No one can remember that the program is named
# `xdg-open`.
#
# On some systems a program named `open` might already exist. Only
# define `open` as alias if no such program exists.
#
if ! type -p open &> /dev/null; then
  alias open='xdg-open'
fi

# Define aliases to quickly control the system and user units, e.g.
# services, mounts, timers etc., managed and supervised by _Systemd_.
#
alias sd='systemctl'
alias sds='systemctl --system'
alias sdu='systemctl --user'

# Use extended instead of basic regular expressions by default.
#
alias sed='sed --regexp-extended'

# Define aliases for the most common commands to control _Kubernetes_
# clusters via the `kubectl` program.
#
if type -p kubectl &> /dev/null; then
  alias k='kubectl'
  alias ka='kubectl apply'
  alias kc='kubectl cp'
  alias kd='kubectl describe'
  alias ke='kubectl explain'
  alias kg='kubectl get'
  alias ki='kubectl cluster-info'
  alias kl='kubectl logs'
  alias ko='kubectl config'
  alias kp='kubectl patch'
  alias kr='kubectl delete'
  alias kt='kubectl top'
  alias kv='kubectl version'
  alias kx='kubectl exec'
fi

# List Vi-like key bindings in different modes.
#
alias vi-command='bind -m vi-command -p \
  | \grep --extended-regexp --invert-match "^#|self-insert$"'
alias vi-command-all='bind -m vi-command -p'
alias vi-insert='bind -m vi-insert -p \
  | \grep --extended-regexp --invert-match "^#|self-insert$"'
alias vi-insert-all='bind -m vi-insert -p'

# Define aliases to ease access to the terminal multiplexer program
# _Tmux_.
#
if type -p tmux &> /dev/null; then
  # Expect terminals to display 256 colors.
  alias tmux='tmux -2'
  alias t='tmux'
  alias tt='{ tmux attach-session || tmux new-session; } &> /dev/null'
  alias tas='tmux attach-session'
  alias tdc='tmux detach-client'
  alias tks='tmux kill-session'
  alias tlc='tmux list-clients'
  alias tls='tmux list-sessions'
  alias tns='tmux new-session'
  alias trc='tmux refresh-client'
fi

# Define aliases and functions to ease job control.
#
if type -p fzf fzf-jobs &> /dev/null; then
  function jb {
    eval "$(jobs | cmd='bg' fzf-jobs "$@")"
  }

  function jd {
    eval "$(jobs | cmd='disown' fzf-jobs "$@")"
  }

  function jdh {
    eval "$(jobs | cmd='disown -h' fzf-jobs "$@")"
  }

  function jf {
    eval "$(jobs | cmd='fg' fzf-jobs "$@")"
  }

  function jj {
    eval "$(jobs | cmd='jobs' fzf-jobs "$@")"
  }

  function jkc {
    eval "$(jobs | cmd='kill -SIGCONT' fzf-jobs "$@")"
  }

  function jkk {
    eval "$(jobs | cmd='kill -SIGKILL' fzf-jobs "$@")"
  }

  function jkt {
    eval "$(jobs | cmd='kill -SIGTERM' fzf-jobs "$@")"
  }
else
  alias jb='bg'
  alias jd='disown'
  alias jdh='disown -h'
  alias jf='fg'
  alias jj='jobs'
  alias jkc='kill -SIGCONT'
  alias jkk='kill -SIGKILL'
  alias jkt='kill -SIGTERM'
fi

# Define _Git_ itself as well as all of its aliases as _Bash_ aliases
# with the prefix letter `g`.  The _Git_ aliases will be lazily loaded
# and defined as _Bash_ aliases by the `git` function below.  Upon the
# first time this function is called it dynamically defines one _Bash_
# alias for e	ach _Git_ alias that is defined in one of _Git's_
# configuration files.  It then executes the `git` command with all the
# given arguments as if this function had never existed.  Once completed
# it eventually makes way for the `git` command by undefining itself.
#
function git {
  alias g='git'
  local git_alias
  for git_alias in $(command git config --list --name-only \
      | command grep '^alias\.' \
      | command cut --delimiter=. --fields=2); do
    alias "g$git_alias=git $git_alias"
  done
  command git "$@"
  unset -f git
}

# Test if fuzzy finder program _Fzf_ is installed.
if type -p fzf &> /dev/null; then
  # Test if _Fzf_ specific _Readline_ file is readable.
  if [[ -f ~/.inputrc.fzf && -r ~/.inputrc.fzf ]]; then
    # Make _Fzf_ available through _Readline_ key bindings.
    bind -f ~/.inputrc.fzf
  fi
  source fzf-insert.bash &> /dev/null
  if source fzf-files.bash &> /dev/null; then
    bind -m vi-insert -x '"\C-af": "fzf_files"'
    bind -m vi-command '"\C-af": "i\C-af"'
  fi
  if source fzf-folders.bash &> /dev/null; then
    bind -m vi-insert -x '"\C-ad": "fzf_folders"'
    bind -m vi-command '"\C-ad": "i\C-ad"'
  fi
  if type -p fzf-git-branch &> /dev/null; then
    bind -m vi-insert -x '"\C-gb": "fzf-git-branch"'
    bind -m vi-command '"\C-gb": "i\C-gb"'
    bind -m vi-insert -x \
      '"\C-gr": "branch_opts=--remotes fzf-git-branch"'
    bind -m vi-command '"\C-gr": "i\C-gr"'
  fi
  if source fzf-git-branch-insert.bash &> /dev/null; then
    bind -m vi-insert -x '"\C-ab": "fzf_git_branch_insert"'
    bind -m vi-command '"\C-ab": "i\C-ab"'
    bind -m vi-insert -x \
      '"\C-ar": "branch_opts=--remotes fzf_git_branch_insert"'
    bind -m vi-command '"\C-ar": "i\C-ar"'
  fi
  if type -p fzf-git-tag &> /dev/null; then
    bind -m vi-insert -x '"\C-gt": "fzf-git-tag"'
    bind -m vi-command '"\C-gt": "i\C-gt"'
  fi
  if source fzf-git-tag-insert.bash &> /dev/null; then
    bind -m vi-insert -x '"\C-at": "fzf_git_tag_insert"'
    bind -m vi-command '"\C-at": "i\C-at"'
  fi
fi

# Test if interactive shell has startup file with local overrides.
if [[ -f ~/.bashrc.local && -r ~/.bashrc.local ]]; then
  # Read and execute commands from that startup file.
  source ~/.bashrc.local
fi

# Test if _GnuPG_ for encrypting and signing data is installed.
if type -p gpg &> /dev/null; then
  # Let _GnuPG_ know on which terminal to interact with the user; for
  # example the _Gpg-agent_ daemon prompting for the passphrase.
  export GPG_TTY="$(tty)"
  echo UPDATESTARTUPTTY | gpg-connect-agent &> /dev/null
fi

# Test if neither a _Tmux_ nor _Screen_ nor _SSH_ session from
# `localhost` is running.
if ! [[ -n "$TMUX" || "$TERM" =~ screen
    || "$SSH_CONNECTION" =~ ^::1|^127\.0\.0\.1 ]]; then
  # Test if _Tmux_ is on the `$PATH`.
  if type -p tmux &> /dev/null; then
    # Try to attach to latest unattached session or start a new one.
    { tmux attach-session || tmux new-session; } &> /dev/null
  fi
fi
